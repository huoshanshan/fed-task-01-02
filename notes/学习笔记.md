函数式编程
    什么是函数式编程（Fanction Programming  ，FP）
    函数式一等公民
        函数可以存储在变量中
        函数作为参数
        函数作为返回值
    高阶函数（higher-order-fanction）
        可以把函数作为参数传递给另一个函数
        可以把函数作为另一个函数的返回结果
        高阶函数就是用来抽象通用的问题
        常用的高阶函数有：forEeah、map、filter、every、some、find、reduce、sort。。。
    闭包
        函数和其周围的状态的引用捆绑在一起形成闭包，可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员
    纯函数
        相同的输入永远会得到相同的输出
        lodash库
    柯里化
        柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
        这是一种对函数参数的缓存
        让函数变的更灵活，让函数的粒度更小
        可以把多元函数转换成一元函数，可以组合使用产生强大的功能
    函数组合
        函数组合可以让我们把细粒度的函数，在执行的过程中，把参数输入给执行的第一个参数，当第一个函数执行完成后，生成的中间结果传递给下一个函数处理，当最后一个函数吃力完成后，把最终的结果返回
    PointFree
        不需要指明处理的数据
        只需要合成运算过程
        需要定义一些辅助的基本运算函数
    函子 functor
        mayBe：处理传入空值返回错误处理的函子
        Either：函子中出现异常让函子变的纯，Either函子可以用来处理这种不纯的函子的异常
        IO：内部的_value是一个函数，可以把不纯的操作存储到_value中延迟操作，把不纯的操作交给调用者处理
        folktale：是一个函数式编程的库提供了一些函数式处理的操作，函数组合，柯里化和一些函子Task、Either、maybe
        task：处理异步任务
        pointed：实现of静态方法的函子
        Monad：可以变扁的pindted函子，解决函子嵌套的问题

javascript性能优化
    内存管理
        申请 ：自动申请，定义变量即申请内存空间
        使用：读写操作即是使用内存空间
        释放：变量不在被引用
    垃圾回收与常见的GC算法
        垃圾
            对象不在被引用时是垃圾（引用，作用域链）
            对象不能从根上访问到时是垃圾，全局执行上下文就是根
        GC算法
            引用计数
                引用计数的工作原理：核心思想设置引用数，判断当前引用数市口为0来判断是不是垃圾，为0的时候GC就开始工作，将其所在的内存空间释放回收再利用，引用计数器，引用关系发生改变时修改引用数字，每次引用计数器加一，减少引用的时候计数器减一，直到计数器变为0立即回收
            标记清除
                分为标记和清除两阶段：首先标记出所有需要回收的对象，然后统一回收所有被标记的对象
                缺点
                1、标记阶段和清除阶段的效率都不高。
                2、显而易见的，清除后产生了大量不连续的内存碎片，导致在程序运行过程中需要分配较大对象的时候，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。
            标记整理
                标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
            分代回收
                1、在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。只需要付出少量存活对象的复制成本就可以完成收集。
                2、老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须用标记-清除或者标记-整理。
    V8引擎的垃圾回收
        js执行引擎
        采用即时编译
        内存设有上限
    performance工具
        chrome的工具
        时序图监控内存变化
        内存问题的相关分析
        任务管理器监控内存变化
        使用堆快照查找出分离DOM
    代码优化
        Jsperf工具
        缓存全局变量
        通过原型对象添加方法
        避开闭包陷阱
        避免属性访问方法使用
        For循环优化
        选择最优的循环方法（forEach）
        文档碎片优化节点添加
        克隆优化节点操作
        直接量替换 new Object
